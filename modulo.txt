Handling modular arithmetic and ASCII characters in hex: 

take the input character in hex (e.g. N = 4Eh )
subtract the start of the ASCII alphabet from it (e.g. 4Eh - 41h = 0Dh)

take the second input character i.e. the "subkey" as Swiegart calls it (e.g. Z = 5Ah)
subtract the start of the ASCII alphabet from it (e.g. 5Ah - 41h = 19h)

add the two results together (0Dh + 19h = 26h) and apply modulo 26d (for characters in the alphabet) IN HEX (which is 1Ah)

e.g. 26h % 1Ah = 0Ch

add the start of the ASCII alphabet back in (e.g. 0Ch + 41h = 4D or the uppercase M)

This completes the keying: N + Z = M. 

Modulo can be accomplished in ASM by use of a simple DIV function. A decent C compiler won't do that (it'll use some magic number that is 2^x divided by y and rounded up), 
but in a toy like this, we're not hurting for CPU cycles, here. 

Working division at the individual character level (i.e., by the byte) is going to be a little weird on a 64 bit architecture, but my references suggest that what SHOULD
happen is that whatever number (probably in a buffer) that's being encoded will be the explicit operand and the number being divided by (1Ah) will need to go into AL.
This should result in the buffer being unaltered, the (useless, in this case) quotient being in AL, and the remainder (the modulus, what is really needed here) in AH. 
AH then gets 41h added back to it, and written out on the next write operation. Voila. Vigenere cypher, which, with a key-length of n characters, produce 26^n possible
keys.

To decrypt, the process above works in reverse: 
4Dh - 5Ah = FFFFFFFFFFFFFFF3h (-13)
FFFFFFFFFFFFFFF3h % 1Ah  = 0Dh
0Dh + 41h = 4Eh (Uppercase N)

Now, this negative number thing presents a problem since DIV is for UNSIGNED numbers, so I'll just have to experiment and see if IDIV works or not. 
Interestingly, I know -13 can be represented in 2's complement binary (it's 1111 0011), but I'm not sure if hex can actually represent that in an 8-bit number. 
I might have to work in decimal instead (for which the offset is 65d, not 41h).  

Interesting sub-note; it seems that the only difference between a vigenere cypher and a one-time pad is key length; vigenere is fixed/limited and OTP is unlimited 
(which is to say, vigenere eventually repeats, OTP does not).
